


// -----------------------------------------------------------------------------

// import axios from "axios";
import axios from "axios";
import { xAckBulk, xReadBulk } from "@uptimematrix/redisstream/client";
import { prismaClient } from "@uptimematrix/store/client";
const GROUP_NAME = process.env.GROUP_NAME!;
const CONSUMER_NAME = process.env.CONSUMER_NAME!;

console.log("Group Name and types is ",GROUP_NAME,typeof GROUP_NAME);
console.log("Consumer Name and types is ",CONSUMER_NAME,typeof CONSUMER_NAME);
if (!GROUP_NAME || !CONSUMER_NAME) {
    throw new Error("Missing GROUP_NAME or CONSUMER_NAME environment variables.");
  }
  
// GROUP_NAME is the name of the consumer group and also represent the region_id

async function main() {
    console.log("Worker started");

    while (true) {
        const response = await xReadBulk(GROUP_NAME, CONSUMER_NAME);

        if (!response || response.length === 0) {
            console.log("No new messages.");
            await new Promise(r => setTimeout(r, 10000)); // wait before polling again
            continue;
        }

        for (const stream of response) {
            const eventsIds: string[] = [];  // here the eventsIds ids is eventIds that is generated by redis that will have all the message ids in eventsIds array.
                const promises = stream.messages.map(async (msg:any)=>{



                // const eventId = msg.id;
                const fields = msg.message;
                const Websiteurl = fields.url;
                const Websiteid = fields.id;
                await fetchWebsite(Websiteurl, Websiteid);
                eventsIds.push(msg.id); // collect message ID for bulk ack

                /*
                -----------------------------------------------------------------------
                // await xAck(GROUP_NAME, eventId); 
                -----------------------------------------------------------------------
                

                // Acknowledge after processing // Here the evenetId is streamId of message that is generated by redis.
                // Okay but now i am using xBulkAck  Use xAckBulk(...) for batch ack (for efficiency)
                
                // If Harkirat (as you mentioned) prefers using xAckBulk — that’s typically for efficiency when acknowledging hundreds of messages. But your per-message xAck(...) is more readable and clear, and totally okay when message volume is low to moderate.
                
                // Harkirat Takes the little different approch call AckBulk but i prefered now to call just after each website fetched that makes for more readable code and also there is no problem same thing happing.
                -----------------------------------------------------------------------
                
                */
            });

            /*
            Always acknowledge after you're 100% done processing.
            That’s i am doing. Promise.all → xAckBulk.
            */ 
            await Promise.all(promises);    
            // Now when everything fetch completed that makes sense to ack all the messages.
            await xAckBulk(GROUP_NAME, eventsIds); 
        }
    }
}

const fetchWebsite = async (Websiteurl:string,Websiteid:string)=>{
    return new Promise<void>(async (resolve,reject)=>{


        const startTime = Date.now();

        // 1. Look up region UUID
        const region = await prismaClient.region.upsert({
            where: { name: GROUP_NAME },
            update: {},
            create: { name: GROUP_NAME },
          });
          console.log("--------------=========================",region);


        console.log("Processing website:", { Websiteid, Websiteurl });
        //wrapping each axios.get() call in a new Promise, and not awaiting it — which makes it fire and run asynchronously, allowing parallel execution across the loop
        axios.get(Websiteurl)
            .then(async ()=>{
                const endTime = Date.now();
                await prismaClient.websiteTick.create({
                    data:{
                        response_time_ms:endTime-startTime,
                        status:"Online",
                        Website_: { connect: { id: Websiteid } },
                        Region_: { connect: { id: region.id } },
                    }
                })
                resolve();
            })
            .catch(async (e)=>{
                console.log("Error",e);
                await prismaClient.websiteTick.create({
                    data:{
                        response_time_ms:0,
                        status:"Offline",
                        Website_: { connect: { id: Websiteid } },
                        Region_: { connect: { id: region.id } },
                    }
                })
                resolve();
            })

    })

}

main();
